====================
FILE: src/main/java/client/Client.java

package client;

import java.io.IOException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

class Client {

  private static final Logger logger = LogManager.getLogger(Client.class);
  private static final ClientFacade clientFacade = new ClientFacade();

  public static void main(String[] args) {
    try {
      clientFacade.startConnection();
      clientFacade.handleUserInput();
    } catch (IOException e) {
      logger.error("Connection error " + e.getMessage());
    } finally {
      try {
        clientFacade.stopConnection();
      } catch (IOException e) {
        logger.error("Error closing connection: " + e.getMessage());
      }
    }
  }
}
====================
FILE: src/main/java/client/ClientCommand.java

package client;

enum ClientCommand {
  UPTIME("UPTIME"),
  INFO("INFO"),
  HELP("HELP"),
  REMOVE_USER("REMOVE_USER"),
  USERS("USERS"),
  SEND_MESSAGE("SEND_MESSAGE"),
  LOGIN("LOGIN"),
  READ_MESSAGES("READ_MESSAGES"),
  ADD_USER("ADD_USER");

  ClientCommand(String info) {}
}

====================
FILE: src/main/java/client/ClientFacade.java

package client;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import config.Config;
import config.ConfigReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import user.Role;
import user.UserSession;

class ClientFacade {

  private static final Logger logger = LogManager.getLogger(ClientFacade.class);
  private static final Scanner scanner = new Scanner(System.in);
  private static final ObjectMapper mapper = new ObjectMapper();
  private static final UserSession session = new UserSession();
  private Socket clientSocket;
  private PrintWriter out;
  private BufferedReader in;

  void startConnection() throws IOException {
    Config config = ConfigReader.loadConfig();
    int port = config.getPort();
    String clientIp = config.getClientIp();
    clientSocket = new Socket(clientIp, port);
    out = new PrintWriter(clientSocket.getOutputStream(), true);
    in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
    logger.info("Client successfully connected");
  }

  void stopConnection() throws IOException {
    if (clientSocket != null) {
      clientSocket.close();
      logger.info("Client disconnected");
    }
  }

  void handleUserInput() throws IOException {
    String input;
    while (!clientSocket.isClosed()) {
      displayMainMenu();
      input = scanner.nextLine();
      try {
        if (processUserCommand(input)) {
          return;
        }
      } catch (NumberFormatException e) {
        logger.error("Invalid input: " + input);
        logger.info("Invalid input, please enter a number.");
      }
    }
  }

  private boolean processUserCommand(String input) throws IOException {
    int commandNumber = Integer.parseInt(input.trim());
    switch (commandNumber) {
      case 1 -> manageUsers();
      case 2 -> loginToApplication();
      case 3 -> readMessages();
      case 4 -> sendMessage();
      case 5 -> logout();
      case 9 -> manageApplicationInfo();
      case 0 -> {
        logger.info("Exiting application");
        stopConnection();
        return true;
      }
      default -> logger.info("Unknown request. Please enter a valid option.");
    }
    return false;
  }

  private void displayMainMenu() {
    if (session.isLoggedIn()) {
      if (session.getRole() == Role.ADMIN) {
        displayAdminMenu();
      } else {
        displayUserMenu();
      }
    } else {
      displayGuestMenu();
    }
  }

  private void loginToApplication() {
    if (session.isLoggedIn()) {
      logger.info("You are already logged in");
      return;
    }
    logger.info("Login to application");
    logger.info("Enter username: ");
    String username = scanner.nextLine().toLowerCase();
    logger.info("Enter password: ");
    String password = scanner.nextLine();
    String userDetails = String.format("{\"username\":\"%s\", \"password\":\"%s\"}", username, password);
    String response = messageServer("LOGIN " + userDetails);
    if (response.contains("successfully")) {
      try {
        JsonNode rootNode = mapper.readTree(response);
        String roleString = rootNode.path("role").asText();
        Role role = Role.valueOf(roleString);
        session.login(username, role);
        logger.info("Login successful. Welcome, " + username + "!");
      } catch (IOException e) {
        logger.error("Error processing login response: " + e.getMessage());
      }
    } else {
      logger.error("Login failed: " + response);
    }
  }

  private void readMessages() {
    if (session.isLoggedIn()) {
      logger.info("Read messages");
      String userDetails = String.format("{\"username\":\"%s\"}", session.getUsername());
      messageServer(ClientCommand.READ_MESSAGES + " " + userDetails);
    } else {
      logger.info("You must be logged in to read messages.");
    }
  }

  private void sendMessage() {
    if (session.isLoggedIn()) {
      logger.info("Send message");
      logger.info("Enter message: ");
      String content = scanner.nextLine();
      logger.info("Enter receiver: ");
      String receiver = scanner.nextLine();
      String userDetails = String.format("{\"content\":\"%s\", \"sender\":\"%s\", \"receiver\":\"%s\"}", content, session.getUsername(), receiver);
      messageServer(ClientCommand.SEND_MESSAGE + " " + userDetails);
    } else {
      logger.info("You must be logged in to send messages.");
    }
  }

  private void manageUsers() {
    if (session.isLoggedIn() && session.getRole() == Role.ADMIN) {
      String userInput = "";
      while (!"0".equals(userInput)) {
        displayManageUsersMenu();
        userInput = scanner.nextLine();
        try {
          int userCommand = Integer.parseInt(userInput.trim());
          switch (userCommand) {
            case 1 -> {
              logger.info("Show user list");
              messageServer(ClientCommand.USERS.toString());
            }
            case 2 -> {
              logger.info("Add user selected");
              addUser();
            }
            case 3 -> {
              logger.info("Remove user selected");
              removeUser();
            }
            case 0 -> {
              logger.info("Returning to main menu");
              return;
            }
            default -> logger.info("Unknown request. Please enter 1, 2, 3, or 0.");
          }
        } catch (NumberFormatException e) {
          logger.error("Invalid input: " + userInput);
          logger.info("Invalid input, please enter a number (1, 2, 3, or 0).");
        }
      }
    } else {
      logger.info("You must be logged in as an admin to manage users.");
    }
  }

  private void removeUser() {
    logger.info("Enter username: ");
    String username = scanner.nextLine();
    messageServer(ClientCommand.REMOVE_USER + " " + username);
  }

  private void addUser() {
    logger.info("Enter username: ");
    String username = scanner.nextLine();
    logger.info("Enter password: ");
    String password = scanner.nextLine();
    logger.info("Enter role (USER/ADMIN): ");
    String roleString = scanner.nextLine().toUpperCase();
    Role role = Role.valueOf(roleString);
    String userDetails = String.format("{\"username\":\"%s\", \"password\":\"%s\", \"role\":\"%s\"}", username, password, role);
    messageServer(ClientCommand.ADD_USER + " " + userDetails);
  }

  private void manageApplicationInfo() {
    displayApplicationInfoMenu();
    String userInput = scanner.nextLine();
    try {
      int userCommand = Integer.parseInt(userInput.trim());
      switch (userCommand) {
        case 1 -> messageServer(ClientCommand.UPTIME.toString());
        case 2 -> messageServer(ClientCommand.INFO.toString());
        case 3 -> messageServer(ClientCommand.HELP.toString());
        case 0 -> logger.info("Returning to main menu");
        default -> logger.info("Unknown request. Please enter 1, 2, 3 or 0.");
      }
    } catch (NumberFormatException e) {
      logger.error("Invalid input: " + userInput);
      logger.info("Invalid input, please enter a number (1, 2, 3 or 0).");
    }
  }

  private String messageServer(String command) {
    out.println(command);
    try {
      String resp = in.readLine();
      handleResponse(resp);
      return resp;
    } catch (IOException e) {
      logger.error("Error reading message from server: " + e.getMessage());
      throw new RuntimeException(e);
    }
  }

  private void handleResponse(String jsonResp) {
    try {
      JsonNode rootNode = mapper.readTree(jsonResp);
      String prettyString = rootNode.toPrettyString();
      logger.info(prettyString);
    } catch (IOException e) {
      logger.error("Error processing JSON response: " + e.getMessage());
    }
  }

  private void logout() {
    if (session.isLoggedIn()) {
      session.logout();
      logger.info("Successfully logged out");
    } else {
      logger.info("You are not logged in");
    }
  }

  private void displayApplicationInfoMenu() {
    logger.info("Application Info Menu: "
        + "\n (1) - Show server uptime"
        + "\n (2) - Show server information"
        + "\n (3) - Show list of available commands"
        + "\n (0) - Return to main menu"
        + "\n");
  }

  private void displayManageUsersMenu() {
    logger.info("Manage Users Menu: "
        + "\n (1) - Show user list"
        + "\n (2) - Add user"
        + "\n (3) - Remove user"
        + "\n (0) - Return to main menu"
        + "\n");
  }


  private void displayAdminMenu() {
    logger.info("Type one of the options: "
        + "\n (1) - manage users"
        + "\n (2) - login to application"
        + "\n (3) - read messages"
        + "\n (4) - send message"
        + "\n (5) - logout"
        + "\n (0) - exit"
        + "\n");
  }

  private void displayUserMenu() {
    logger.info("Type one of the options: "
        + "\n (3) - read messages"
        + "\n (4) - send message"
        + "\n (5) - logout"
        + "\n (0) - exit"
        + "\n");
  }

  private void displayGuestMenu() {
    logger.info("Type one of the options: "
        + "\n (1) - manage users"
        + "\n (2) - login to application"
        + "\n (9) - application info"
        + "\n (0) - exit"
        + "\n");
  }
}

====================
FILE: src/main/java/config/Config.java

package config;

public class Config {
  private String clientIp;
  private int port;

  public String getClientIp() {
    return clientIp;
  }

  public void setClientIp(String clientIp) {
    this.clientIp = clientIp;
  }

  public int getPort() {
    return port;
  }

  public void setPort(int port) {
    this.port = port;
  }
}

====================
FILE: src/main/java/config/ConfigReader.java

package config;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;

public class ConfigReader {

  public static Config loadConfig() {
    ObjectMapper objectMapper = new ObjectMapper();
    Config config = new Config();
    try (InputStream inputStream = ConfigReader.class.getClassLoader().getResourceAsStream("config.json")) {
      if (inputStream == null) {
        throw new IOException("Sorry, unable to find config.json");
      }
      JsonNode rootNode = objectMapper.readTree(inputStream);

      config.setClientIp(rootNode.path("clientIp").asText());
      config.setPort(rootNode.path("port").asInt());

      return config;
    } catch (IOException ex) {
      ex.printStackTrace();
      return null;
    }
  }
}

====================
FILE: src/main/java/database/Database.java

package database;

import com.mysql.cj.jdbc.MysqlDataSource;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class Database {

  private final DSLContext create;

  public Database() {
    Properties properties = loadProperties();
    MysqlDataSource dataSource = new MysqlDataSource();
    dataSource.setURL(properties.getProperty("db.url"));
    dataSource.setUser(properties.getProperty("db.user"));
    dataSource.setPassword(properties.getProperty("db.password"));

    this.create = DSL.using(dataSource, org.jooq.SQLDialect.MYSQL);
  }

  private Properties loadProperties() {
    Properties properties = new Properties();
    try (InputStream input = getClass().getClassLoader().getResourceAsStream("application.properties")) {
      if (input == null) {
        throw new RuntimeException("Sorry, unable to find application.properties");
      }
      properties.load(input);
    } catch (IOException ex) {
      ex.printStackTrace();
      throw new RuntimeException("Failed to load database properties", ex);
    }
    return properties;
  }

  public DSLContext getDSLContext() {
    return create;
  }
}

====================
FILE: src/main/java/db/Cs.java

/*
 * This file is generated by jOOQ.
 */
package db;


import db.tables.Messages;
import db.tables.Users;

import java.util.Arrays;
import java.util.List;

import org.jooq.Catalog;
import org.jooq.Table;
import org.jooq.impl.SchemaImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Cs extends SchemaImpl {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>cs</code>
     */
    public static final Cs CS = new Cs();

    /**
     * The table <code>cs.messages</code>.
     */
    public final Messages MESSAGES = Messages.MESSAGES;

    /**
     * The table <code>cs.users</code>.
     */
    public final Users USERS = Users.USERS;

    /**
     * No further instances allowed
     */
    private Cs() {
        super("cs", null);
    }


    @Override
    public Catalog getCatalog() {
        return DefaultCatalog.DEFAULT_CATALOG;
    }

    @Override
    public final List<Table<?>> getTables() {
        return Arrays.asList(
            Messages.MESSAGES,
            Users.USERS
        );
    }
}

====================
FILE: src/main/java/db/DefaultCatalog.java

/*
 * This file is generated by jOOQ.
 */
package db;


import java.util.Arrays;
import java.util.List;

import org.jooq.Constants;
import org.jooq.Schema;
import org.jooq.impl.CatalogImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class DefaultCatalog extends CatalogImpl {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>DEFAULT_CATALOG</code>
     */
    public static final DefaultCatalog DEFAULT_CATALOG = new DefaultCatalog();

    /**
     * The schema <code>cs</code>.
     */
    public final Cs CS = Cs.CS;

    /**
     * No further instances allowed
     */
    private DefaultCatalog() {
        super("");
    }

    @Override
    public final List<Schema> getSchemas() {
        return Arrays.asList(
            Cs.CS
        );
    }

    /**
     * A reference to the 3.16 minor release of the code generator. If this
     * doesn't compile, it's because the runtime library uses an older minor
     * release, namely: 3.16. You can turn off the generation of this reference
     * by specifying /configuration/generator/generate/jooqVersionReference
     */
    private static final String REQUIRE_RUNTIME_JOOQ_VERSION = Constants.VERSION_3_16;
}

====================
FILE: src/main/java/db/Indexes.java

/*
 * This file is generated by jOOQ.
 */
package db;


import db.tables.Messages;

import org.jooq.Index;
import org.jooq.OrderField;
import org.jooq.impl.DSL;
import org.jooq.impl.Internal;


/**
 * A class modelling indexes of tables in cs.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Indexes {

    // -------------------------------------------------------------------------
    // INDEX definitions
    // -------------------------------------------------------------------------

    public static final Index MESSAGES_RECEIVER_ID = Internal.createIndex(DSL.name("receiver_id"), Messages.MESSAGES, new OrderField[] { Messages.MESSAGES.RECEIVER_ID }, false);
    public static final Index MESSAGES_SENDER_ID = Internal.createIndex(DSL.name("sender_id"), Messages.MESSAGES, new OrderField[] { Messages.MESSAGES.SENDER_ID }, false);
}

====================
FILE: src/main/java/db/Keys.java

/*
 * This file is generated by jOOQ.
 */
package db;


import db.tables.Messages;
import db.tables.Users;
import db.tables.records.MessagesRecord;
import db.tables.records.UsersRecord;

import org.jooq.ForeignKey;
import org.jooq.TableField;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.Internal;


/**
 * A class modelling foreign key relationships and constraints of tables in cs.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Keys {

    // -------------------------------------------------------------------------
    // UNIQUE and PRIMARY KEY definitions
    // -------------------------------------------------------------------------

    public static final UniqueKey<MessagesRecord> KEY_MESSAGES_PRIMARY = Internal.createUniqueKey(Messages.MESSAGES, DSL.name("KEY_messages_PRIMARY"), new TableField[] { Messages.MESSAGES.ID }, true);
    public static final UniqueKey<UsersRecord> KEY_USERS_PRIMARY = Internal.createUniqueKey(Users.USERS, DSL.name("KEY_users_PRIMARY"), new TableField[] { Users.USERS.ID }, true);

    // -------------------------------------------------------------------------
    // FOREIGN KEY definitions
    // -------------------------------------------------------------------------

    public static final ForeignKey<MessagesRecord, UsersRecord> MESSAGES_IBFK_1 = Internal.createForeignKey(Messages.MESSAGES, DSL.name("messages_ibfk_1"), new TableField[] { Messages.MESSAGES.SENDER_ID }, Keys.KEY_USERS_PRIMARY, new TableField[] { Users.USERS.ID }, true);
    public static final ForeignKey<MessagesRecord, UsersRecord> MESSAGES_IBFK_2 = Internal.createForeignKey(Messages.MESSAGES, DSL.name("messages_ibfk_2"), new TableField[] { Messages.MESSAGES.RECEIVER_ID }, Keys.KEY_USERS_PRIMARY, new TableField[] { Users.USERS.ID }, true);
}

====================
FILE: src/main/java/db/Tables.java

/*
 * This file is generated by jOOQ.
 */
package db;


import db.tables.Messages;
import db.tables.Users;


/**
 * Convenience access to all tables in cs.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Tables {

    /**
     * The table <code>cs.messages</code>.
     */
    public static final Messages MESSAGES = Messages.MESSAGES;

    /**
     * The table <code>cs.users</code>.
     */
    public static final Users USERS = Users.USERS;
}

====================
FILE: src/main/java/db/enums/UsersRole.java

/*
 * This file is generated by jOOQ.
 */
package db.enums;


import org.jooq.Catalog;
import org.jooq.EnumType;
import org.jooq.Schema;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public enum UsersRole implements EnumType {

    USER("USER"),

    ADMIN("ADMIN");

    private final String literal;

    private UsersRole(String literal) {
        this.literal = literal;
    }

    @Override
    public Catalog getCatalog() {
        return null;
    }

    @Override
    public Schema getSchema() {
        return null;
    }

    @Override
    public String getName() {
        return "users_role";
    }

    @Override
    public String getLiteral() {
        return literal;
    }

    /**
     * Lookup a value of this EnumType by its literal
     */
    public static UsersRole lookupLiteral(String literal) {
        return EnumType.lookupLiteral(UsersRole.class, literal);
    }
}

====================
FILE: src/main/java/db/tables/Messages.java

/*
 * This file is generated by jOOQ.
 */
package db.tables;


import db.Cs;
import db.Indexes;
import db.Keys;
import db.tables.records.MessagesRecord;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Identity;
import org.jooq.Index;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Row5;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Messages extends TableImpl<MessagesRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>cs.messages</code>
     */
    public static final Messages MESSAGES = new Messages();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<MessagesRecord> getRecordType() {
        return MessagesRecord.class;
    }

    /**
     * The column <code>cs.messages.id</code>.
     */
    public final TableField<MessagesRecord, Integer> ID = createField(DSL.name("id"), SQLDataType.INTEGER.nullable(false).identity(true), this, "");

    /**
     * The column <code>cs.messages.content</code>.
     */
    public final TableField<MessagesRecord, String> CONTENT = createField(DSL.name("content"), SQLDataType.CLOB.nullable(false), this, "");

    /**
     * The column <code>cs.messages.sender_id</code>.
     */
    public final TableField<MessagesRecord, Integer> SENDER_ID = createField(DSL.name("sender_id"), SQLDataType.INTEGER.nullable(false), this, "");

    /**
     * The column <code>cs.messages.receiver_id</code>.
     */
    public final TableField<MessagesRecord, Integer> RECEIVER_ID = createField(DSL.name("receiver_id"), SQLDataType.INTEGER.nullable(false), this, "");

    /**
     * The column <code>cs.messages.created_date</code>.
     */
    public final TableField<MessagesRecord, LocalDateTime> CREATED_DATE = createField(DSL.name("created_date"), SQLDataType.LOCALDATETIME(0).nullable(false).defaultValue(DSL.field("current_timestamp()", SQLDataType.LOCALDATETIME)), this, "");

    private Messages(Name alias, Table<MessagesRecord> aliased) {
        this(alias, aliased, null);
    }

    private Messages(Name alias, Table<MessagesRecord> aliased, Field<?>[] parameters) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table());
    }

    /**
     * Create an aliased <code>cs.messages</code> table reference
     */
    public Messages(String alias) {
        this(DSL.name(alias), MESSAGES);
    }

    /**
     * Create an aliased <code>cs.messages</code> table reference
     */
    public Messages(Name alias) {
        this(alias, MESSAGES);
    }

    /**
     * Create a <code>cs.messages</code> table reference
     */
    public Messages() {
        this(DSL.name("messages"), null);
    }

    public <O extends Record> Messages(Table<O> child, ForeignKey<O, MessagesRecord> key) {
        super(child, key, MESSAGES);
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Cs.CS;
    }

    @Override
    public List<Index> getIndexes() {
        return Arrays.asList(Indexes.MESSAGES_RECEIVER_ID, Indexes.MESSAGES_SENDER_ID);
    }

    @Override
    public Identity<MessagesRecord, Integer> getIdentity() {
        return (Identity<MessagesRecord, Integer>) super.getIdentity();
    }

    @Override
    public UniqueKey<MessagesRecord> getPrimaryKey() {
        return Keys.KEY_MESSAGES_PRIMARY;
    }

    @Override
    public List<ForeignKey<MessagesRecord, ?>> getReferences() {
        return Arrays.asList(Keys.MESSAGES_IBFK_1, Keys.MESSAGES_IBFK_2);
    }

    private transient Users _messagesIbfk_1;
    private transient Users _messagesIbfk_2;

    /**
     * Get the implicit join path to the <code>cs.users</code> table, via the
     * <code>messages_ibfk_1</code> key.
     */
    public Users messagesIbfk_1() {
        if (_messagesIbfk_1 == null)
            _messagesIbfk_1 = new Users(this, Keys.MESSAGES_IBFK_1);

        return _messagesIbfk_1;
    }

    /**
     * Get the implicit join path to the <code>cs.users</code> table, via the
     * <code>messages_ibfk_2</code> key.
     */
    public Users messagesIbfk_2() {
        if (_messagesIbfk_2 == null)
            _messagesIbfk_2 = new Users(this, Keys.MESSAGES_IBFK_2);

        return _messagesIbfk_2;
    }

    @Override
    public Messages as(String alias) {
        return new Messages(DSL.name(alias), this);
    }

    @Override
    public Messages as(Name alias) {
        return new Messages(alias, this);
    }

    /**
     * Rename this table
     */
    @Override
    public Messages rename(String name) {
        return new Messages(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public Messages rename(Name name) {
        return new Messages(name, null);
    }

    // -------------------------------------------------------------------------
    // Row5 type methods
    // -------------------------------------------------------------------------

    @Override
    public Row5<Integer, String, Integer, Integer, LocalDateTime> fieldsRow() {
        return (Row5) super.fieldsRow();
    }
}

====================
FILE: src/main/java/db/tables/Users.java

/*
 * This file is generated by jOOQ.
 */
package db.tables;


import db.Cs;
import db.Keys;
import db.enums.UsersRole;
import db.tables.records.UsersRecord;

import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Identity;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Row4;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Users extends TableImpl<UsersRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>cs.users</code>
     */
    public static final Users USERS = new Users();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<UsersRecord> getRecordType() {
        return UsersRecord.class;
    }

    /**
     * The column <code>cs.users.id</code>.
     */
    public final TableField<UsersRecord, Integer> ID = createField(DSL.name("id"), SQLDataType.INTEGER.nullable(false).identity(true), this, "");

    /**
     * The column <code>cs.users.username</code>.
     */
    public final TableField<UsersRecord, String> USERNAME = createField(DSL.name("username"), SQLDataType.VARCHAR(255).nullable(false), this, "");

    /**
     * The column <code>cs.users.password</code>.
     */
    public final TableField<UsersRecord, String> PASSWORD = createField(DSL.name("password"), SQLDataType.VARCHAR(255).nullable(false), this, "");

    /**
     * The column <code>cs.users.role</code>.
     */
    public final TableField<UsersRecord, UsersRole> ROLE = createField(DSL.name("role"), SQLDataType.VARCHAR(5).nullable(false).asEnumDataType(db.enums.UsersRole.class), this, "");

    private Users(Name alias, Table<UsersRecord> aliased) {
        this(alias, aliased, null);
    }

    private Users(Name alias, Table<UsersRecord> aliased, Field<?>[] parameters) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table());
    }

    /**
     * Create an aliased <code>cs.users</code> table reference
     */
    public Users(String alias) {
        this(DSL.name(alias), USERS);
    }

    /**
     * Create an aliased <code>cs.users</code> table reference
     */
    public Users(Name alias) {
        this(alias, USERS);
    }

    /**
     * Create a <code>cs.users</code> table reference
     */
    public Users() {
        this(DSL.name("users"), null);
    }

    public <O extends Record> Users(Table<O> child, ForeignKey<O, UsersRecord> key) {
        super(child, key, USERS);
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Cs.CS;
    }

    @Override
    public Identity<UsersRecord, Integer> getIdentity() {
        return (Identity<UsersRecord, Integer>) super.getIdentity();
    }

    @Override
    public UniqueKey<UsersRecord> getPrimaryKey() {
        return Keys.KEY_USERS_PRIMARY;
    }

    @Override
    public Users as(String alias) {
        return new Users(DSL.name(alias), this);
    }

    @Override
    public Users as(Name alias) {
        return new Users(alias, this);
    }

    /**
     * Rename this table
     */
    @Override
    public Users rename(String name) {
        return new Users(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public Users rename(Name name) {
        return new Users(name, null);
    }

    // -------------------------------------------------------------------------
    // Row4 type methods
    // -------------------------------------------------------------------------

    @Override
    public Row4<Integer, String, String, UsersRole> fieldsRow() {
        return (Row4) super.fieldsRow();
    }
}

====================
FILE: src/main/java/db/tables/records/MessagesRecord.java

/*
 * This file is generated by jOOQ.
 */
package db.tables.records;


import db.tables.Messages;

import java.time.LocalDateTime;

import org.jooq.Field;
import org.jooq.Record1;
import org.jooq.Record5;
import org.jooq.Row5;
import org.jooq.impl.UpdatableRecordImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class MessagesRecord extends UpdatableRecordImpl<MessagesRecord> implements Record5<Integer, String, Integer, Integer, LocalDateTime> {

    private static final long serialVersionUID = 1L;

    /**
     * Setter for <code>cs.messages.id</code>.
     */
    public void setId(Integer value) {
        set(0, value);
    }

    /**
     * Getter for <code>cs.messages.id</code>.
     */
    public Integer getId() {
        return (Integer) get(0);
    }

    /**
     * Setter for <code>cs.messages.content</code>.
     */
    public void setContent(String value) {
        set(1, value);
    }

    /**
     * Getter for <code>cs.messages.content</code>.
     */
    public String getContent() {
        return (String) get(1);
    }

    /**
     * Setter for <code>cs.messages.sender_id</code>.
     */
    public void setSenderId(Integer value) {
        set(2, value);
    }

    /**
     * Getter for <code>cs.messages.sender_id</code>.
     */
    public Integer getSenderId() {
        return (Integer) get(2);
    }

    /**
     * Setter for <code>cs.messages.receiver_id</code>.
     */
    public void setReceiverId(Integer value) {
        set(3, value);
    }

    /**
     * Getter for <code>cs.messages.receiver_id</code>.
     */
    public Integer getReceiverId() {
        return (Integer) get(3);
    }

    /**
     * Setter for <code>cs.messages.created_date</code>.
     */
    public void setCreatedDate(LocalDateTime value) {
        set(4, value);
    }

    /**
     * Getter for <code>cs.messages.created_date</code>.
     */
    public LocalDateTime getCreatedDate() {
        return (LocalDateTime) get(4);
    }

    // -------------------------------------------------------------------------
    // Primary key information
    // -------------------------------------------------------------------------

    @Override
    public Record1<Integer> key() {
        return (Record1) super.key();
    }

    // -------------------------------------------------------------------------
    // Record5 type implementation
    // -------------------------------------------------------------------------

    @Override
    public Row5<Integer, String, Integer, Integer, LocalDateTime> fieldsRow() {
        return (Row5) super.fieldsRow();
    }

    @Override
    public Row5<Integer, String, Integer, Integer, LocalDateTime> valuesRow() {
        return (Row5) super.valuesRow();
    }

    @Override
    public Field<Integer> field1() {
        return Messages.MESSAGES.ID;
    }

    @Override
    public Field<String> field2() {
        return Messages.MESSAGES.CONTENT;
    }

    @Override
    public Field<Integer> field3() {
        return Messages.MESSAGES.SENDER_ID;
    }

    @Override
    public Field<Integer> field4() {
        return Messages.MESSAGES.RECEIVER_ID;
    }

    @Override
    public Field<LocalDateTime> field5() {
        return Messages.MESSAGES.CREATED_DATE;
    }

    @Override
    public Integer component1() {
        return getId();
    }

    @Override
    public String component2() {
        return getContent();
    }

    @Override
    public Integer component3() {
        return getSenderId();
    }

    @Override
    public Integer component4() {
        return getReceiverId();
    }

    @Override
    public LocalDateTime component5() {
        return getCreatedDate();
    }

    @Override
    public Integer value1() {
        return getId();
    }

    @Override
    public String value2() {
        return getContent();
    }

    @Override
    public Integer value3() {
        return getSenderId();
    }

    @Override
    public Integer value4() {
        return getReceiverId();
    }

    @Override
    public LocalDateTime value5() {
        return getCreatedDate();
    }

    @Override
    public MessagesRecord value1(Integer value) {
        setId(value);
        return this;
    }

    @Override
    public MessagesRecord value2(String value) {
        setContent(value);
        return this;
    }

    @Override
    public MessagesRecord value3(Integer value) {
        setSenderId(value);
        return this;
    }

    @Override
    public MessagesRecord value4(Integer value) {
        setReceiverId(value);
        return this;
    }

    @Override
    public MessagesRecord value5(LocalDateTime value) {
        setCreatedDate(value);
        return this;
    }

    @Override
    public MessagesRecord values(Integer value1, String value2, Integer value3, Integer value4, LocalDateTime value5) {
        value1(value1);
        value2(value2);
        value3(value3);
        value4(value4);
        value5(value5);
        return this;
    }

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a detached MessagesRecord
     */
    public MessagesRecord() {
        super(Messages.MESSAGES);
    }

    /**
     * Create a detached, initialised MessagesRecord
     */
    public MessagesRecord(Integer id, String content, Integer senderId, Integer receiverId, LocalDateTime createdDate) {
        super(Messages.MESSAGES);

        setId(id);
        setContent(content);
        setSenderId(senderId);
        setReceiverId(receiverId);
        setCreatedDate(createdDate);
    }
}

====================
FILE: src/main/java/db/tables/records/UsersRecord.java

/*
 * This file is generated by jOOQ.
 */
package db.tables.records;


import db.enums.UsersRole;
import db.tables.Users;

import org.jooq.Field;
import org.jooq.Record1;
import org.jooq.Record4;
import org.jooq.Row4;
import org.jooq.impl.UpdatableRecordImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class UsersRecord extends UpdatableRecordImpl<UsersRecord> implements Record4<Integer, String, String, UsersRole> {

    private static final long serialVersionUID = 1L;

    /**
     * Setter for <code>cs.users.id</code>.
     */
    public void setId(Integer value) {
        set(0, value);
    }

    /**
     * Getter for <code>cs.users.id</code>.
     */
    public Integer getId() {
        return (Integer) get(0);
    }

    /**
     * Setter for <code>cs.users.username</code>.
     */
    public void setUsername(String value) {
        set(1, value);
    }

    /**
     * Getter for <code>cs.users.username</code>.
     */
    public String getUsername() {
        return (String) get(1);
    }

    /**
     * Setter for <code>cs.users.password</code>.
     */
    public void setPassword(String value) {
        set(2, value);
    }

    /**
     * Getter for <code>cs.users.password</code>.
     */
    public String getPassword() {
        return (String) get(2);
    }

    /**
     * Setter for <code>cs.users.role</code>.
     */
    public void setRole(UsersRole value) {
        set(3, value);
    }

    /**
     * Getter for <code>cs.users.role</code>.
     */
    public UsersRole getRole() {
        return (UsersRole) get(3);
    }

    // -------------------------------------------------------------------------
    // Primary key information
    // -------------------------------------------------------------------------

    @Override
    public Record1<Integer> key() {
        return (Record1) super.key();
    }

    // -------------------------------------------------------------------------
    // Record4 type implementation
    // -------------------------------------------------------------------------

    @Override
    public Row4<Integer, String, String, UsersRole> fieldsRow() {
        return (Row4) super.fieldsRow();
    }

    @Override
    public Row4<Integer, String, String, UsersRole> valuesRow() {
        return (Row4) super.valuesRow();
    }

    @Override
    public Field<Integer> field1() {
        return Users.USERS.ID;
    }

    @Override
    public Field<String> field2() {
        return Users.USERS.USERNAME;
    }

    @Override
    public Field<String> field3() {
        return Users.USERS.PASSWORD;
    }

    @Override
    public Field<UsersRole> field4() {
        return Users.USERS.ROLE;
    }

    @Override
    public Integer component1() {
        return getId();
    }

    @Override
    public String component2() {
        return getUsername();
    }

    @Override
    public String component3() {
        return getPassword();
    }

    @Override
    public UsersRole component4() {
        return getRole();
    }

    @Override
    public Integer value1() {
        return getId();
    }

    @Override
    public String value2() {
        return getUsername();
    }

    @Override
    public String value3() {
        return getPassword();
    }

    @Override
    public UsersRole value4() {
        return getRole();
    }

    @Override
    public UsersRecord value1(Integer value) {
        setId(value);
        return this;
    }

    @Override
    public UsersRecord value2(String value) {
        setUsername(value);
        return this;
    }

    @Override
    public UsersRecord value3(String value) {
        setPassword(value);
        return this;
    }

    @Override
    public UsersRecord value4(UsersRole value) {
        setRole(value);
        return this;
    }

    @Override
    public UsersRecord values(Integer value1, String value2, String value3, UsersRole value4) {
        value1(value1);
        value2(value2);
        value3(value3);
        value4(value4);
        return this;
    }

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a detached UsersRecord
     */
    public UsersRecord() {
        super(Users.USERS);
    }

    /**
     * Create a detached, initialised UsersRecord
     */
    public UsersRecord(Integer id, String username, String password, UsersRole role) {
        super(Users.USERS);

        setId(id);
        setUsername(username);
        setPassword(password);
        setRole(role);
    }
}

====================
FILE: src/main/java/message/Message.java

package message;

import com.fasterxml.jackson.annotation.JsonProperty;

public class Message {

  private String content;
  private String sender;
  private String receiver;
  private String createdDate;

  public Message(
      @JsonProperty("content") String content,
      @JsonProperty("sender") String sender,
      @JsonProperty("receiver") String receiver,
      @JsonProperty("createdDate") String date) {
    this.content = content;
    this.sender = sender;
    this.receiver = receiver;
    this.createdDate = date;
  }

  public Message() {
  }

  public String getContent() {
    return content;
  }

  public void setContent(String content) {
    this.content = content;
  }

  public String getSender() {
    return sender;
  }

  public void setSender(String sender) {
    this.sender = sender;
  }

  public String getReceiver() {
    return receiver;
  }

  public void setReceiver(String receiver) {
    this.receiver = receiver;
  }

  public String getCreatedDate() {
    return createdDate;
  }

  public void setCreatedDate(String createdDate) {
    this.createdDate = createdDate;
  }
}

====================
FILE: src/main/java/message/MessageService.java

package message;


import static db.tables.Messages.MESSAGES;
import static db.tables.Users.USERS;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import database.Database;
import java.util.List;
import java.util.stream.Collectors;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import user.User;

public class MessageService {

  private final ObjectMapper objectMapper = new ObjectMapper();
  private final Database database = new Database();
  private final DSLContext create = database.getDSLContext();

  private static final int MESSAGE_SIZE = 255;
  private static final int MAILBOX_SIZE = 5;

  public String sendMessage(String payload) {
    try {
      Message message = objectMapper.readValue(payload, Message.class);

      return create.transactionResult(configuration -> {
        DSLContext ctx = DSL.using(configuration);

        Integer receiverId = ctx.select(USERS.ID)
            .from(USERS)
            .where(USERS.USERNAME.eq(message.getReceiver()))
            .fetchOne(USERS.ID);

        if (receiverId == null) {
          return "{\"error\": \"Receiver not found\"}";
        }

        Integer senderId = ctx.select(USERS.ID)
            .from(USERS)
            .where(USERS.USERNAME.eq(message.getSender()))
            .fetchOne(USERS.ID);

        if (message.getContent().length() >= MESSAGE_SIZE) {
          return "{\"error\": \"Message is too long\"}";
        }

        long numberOfMessages = ctx.select(MESSAGES.ID)
            .from(MESSAGES)
            .where(MESSAGES.RECEIVER_ID.eq(receiverId))
            .stream()
            .count();

        if (numberOfMessages >= MAILBOX_SIZE) {
          return "{\"error\": \"Receiver mailbox is full, cannot send message\"}";
        }

        ctx.insertInto(MESSAGES)
            .set(MESSAGES.CONTENT, message.getContent())
            .set(MESSAGES.SENDER_ID, senderId)
            .set(MESSAGES.RECEIVER_ID, receiverId)
            .execute();

        return "{\"message\": \"Message sent\"}";
      });

    } catch (JsonProcessingException e) {
      e.printStackTrace();
      return "{\"error\": \"Unable to send message\"}";
    }
  }

  public String readMessages(String payload) {
    try {
      String userName = objectMapper.readValue(payload, User.class).getUsername();

      Integer userId = create.select(USERS.ID)
          .from(USERS)
          .where(USERS.USERNAME.eq(userName))
          .fetchOne(USERS.ID);

      if (userId == null) {
        return "{\"error\": \"User not found\"}";
      }

      var USERS_SENDER = USERS.as("USERS_SENDER");
      var USERS_RECEIVER = USERS.as("USERS_RECEIVER");

      List<Message> messages = create
          .select(MESSAGES.CONTENT,
              USERS_SENDER.USERNAME.as("sender"),
              USERS_RECEIVER.USERNAME.as("receiver"),
              MESSAGES.CREATED_DATE)
          .from(MESSAGES)
          .join(USERS_SENDER).on(MESSAGES.SENDER_ID.eq(USERS_SENDER.ID))
          .join(USERS_RECEIVER).on(MESSAGES.RECEIVER_ID.eq(USERS_RECEIVER.ID))
          .fetch()
          .stream()
          .map(record -> new Message(
              record.get(MESSAGES.CONTENT),
              record.get("sender", String.class),
              record.get("receiver", String.class),
              record.get(MESSAGES.CREATED_DATE).toString()
          ))
          .collect(Collectors.toList());

      if (messages.isEmpty()) {
        return "{\"message\": \"Mailbox is empty\"}";
      }

      return objectMapper.writeValueAsString(messages);

    } catch (JsonProcessingException e) {
      e.printStackTrace();
      return "{\"error\": \"Unable to process messages\"}";
    }
  }
}
====================
FILE: src/main/java/server/Response.java

package server;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.time.Duration;
import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Response {

  private final ObjectMapper mapper = new ObjectMapper();

  public String calculateServerTime(Instant startTime) throws JsonProcessingException {
    Duration serverUptime = Duration.between(startTime, Instant.now());
    int hours = serverUptime.toHoursPart();
    int minutes = serverUptime.toMinutesPart();
    int seconds = serverUptime.toSecondsPart();

    String uptimeMessage = String.format("server.Server was started %d hours, %d minutes, %d seconds ago",
        hours, minutes, seconds);
    Map<String, String> uptimeResponse = new ConcurrentHashMap<>();
    uptimeResponse.put("info", uptimeMessage);

    return mapper.writeValueAsString(uptimeResponse);
  }

  public String getCommands(Map<String, String> commandsInfo)
      throws JsonProcessingException {
    return mapper.writeValueAsString(commandsInfo);
  }

  public String getInformation(Map<String, String> information) throws JsonProcessingException {
    return mapper.writeValueAsString(information);
  }
}

====================
FILE: src/main/java/server/Server.java

package server;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.time.Instant;
import java.util.Objects;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import user.Role;
import user.User;
import user.UserService;

public class Server {

  private static final Logger logger = LogManager.getLogger(Server.class);
  private final ServerSocket server;
  private static final int PORT = 5000;
  private final ServerFacade serverFacade;
  private final UserService userService;

  public Server() {
    try {
      server = new ServerSocket(PORT);
    } catch (IOException e) {
      logger.error("Error creating server: " + e.getMessage());
      throw new RuntimeException(e);
    }
    userService = new UserService();
    Instant creationTime = Instant.now();
    serverFacade = new ServerFacade(new Storage(), userService, creationTime);

    // Add two user records to the database
    initializeUsers();

    logger.info("Server successfully started on port " + PORT);
  }

  // Method to initialize users in the database
  private void initializeUsers() {
    try {
      User user1 = new User("john", "password", Role.USER);
      User user2 = new User("admin", "admin", Role.ADMIN);

      // Convert to JSON and add users using UserService
      userService.addUser(userToJson(user1));
      userService.addUser(userToJson(user2));

      logger.info("Added default users to the database.");
    } catch (Exception e) {
      logger.error("Error initializing default users: " + e.getMessage(), e);
    }
  }

  // Helper method to convert a User object to JSON format
  private String userToJson(User user) throws JsonProcessingException {
    return new ObjectMapper().writeValueAsString(user);
  }

  public static void main(String[] args) {
    Server server = new Server();
    try {
      server.run();
    } catch (RuntimeException e) {
      logger.error("Error starting connection: " + e.getMessage());
    }
  }

  public void run() {
    try (
        Socket client = server.accept();
        PrintWriter output = new PrintWriter(new OutputStreamWriter(client.getOutputStream()), true);
        BufferedReader input = new BufferedReader(new InputStreamReader(client.getInputStream()))
    ) {
      logger.info("Client connected");
      String nextLine;
      while (!Objects.isNull(nextLine = input.readLine())) {
        logger.info("Incoming request: " + nextLine);
        try {
          String[] commandParts = nextLine.trim().split(" ", 2);
          String command = commandParts[0].toUpperCase();
          String payload = commandParts.length > 1 ? commandParts[1] : null;

          if (command == null) {
            output.println("{\"error\": \"Incorrect command, try again\"}");
          } else {
            String response = serverFacade.handleRequest(command, payload);
            output.println(response);
          }
        } catch (JsonProcessingException e) {
          logger.error("Error processing request: " + e.getMessage());
          output.println("{\"error\": \"Internal server error\"}");
        }
      }
    } catch (IOException e) {
      logger.error("Cannot connect client: " + e.getMessage());
      throw new RuntimeException(e);
    }
  }
}
====================
FILE: src/main/java/server/ServerCommand.java

package server;

public enum ServerCommand {
  UPTIME,
  INFO,
  HELP,
  REMOVE_USER,
  USERS,
  SEND_MESSAGE,
  LOGIN,
  READ_MESSAGES,
  ADD_USER,
  STOP;
}

====================
FILE: src/main/java/server/ServerFacade.java

package server;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.time.Instant;
import java.util.Map;
import message.MessageService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import user.UserService;

public class ServerFacade {

  private static final Logger logger = LogManager.getLogger(ServerFacade.class);
  private final Instant creationTime;
  private final Storage storage;
  private final UserService userService;
  private final MessageService messageService = new MessageService();
  private final Response response = new Response();
  private final ObjectMapper objectMapper = new ObjectMapper();

  public ServerFacade(Storage storage, UserService userService, Instant creationTime) {
    this.storage = storage;
    this.userService = userService;
    this.creationTime = creationTime;
  }

  public String handleRequest(String request, String payload) throws IOException {
    ServerCommand command;
    try {
      command = ServerCommand.valueOf(request.toUpperCase());
    } catch (IllegalArgumentException e) {
      return "{\"error\": \"Incorrect command, try again\"}";
    }

    return switch (command) {
      case UPTIME -> response.calculateServerTime(creationTime);
      case HELP -> response.getCommands(storage.getCommands());
      case INFO -> response.getInformation(storage.getInformation());
      case USERS -> userService.getUsers();
      case ADD_USER -> userService.addUser(payload);
      case REMOVE_USER -> userService.removeUser(payload);
      case LOGIN -> userService.loginUser(payload);
      case STOP -> stopServer();
      case READ_MESSAGES -> messageService.readMessages(payload);
      case SEND_MESSAGE -> messageService.sendMessage(payload);
      default -> "{\"error\": \"Incorrect command, try again\"}";
    };
  }

  private String stopServer() {
    try {
      logger.info("Connection closed");
      Map<String, String> result = Map.of("message", "Connection closed");
      return objectMapper.writeValueAsString(result);
    } catch (JsonProcessingException e) {
      logger.error("Error closing server: " + e.getMessage());
      throw new RuntimeException(e);
    }
  }
}

====================
FILE: src/main/java/server/Storage.java

package server;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Storage {

  private final Map<String, String> information = new ConcurrentHashMap<>();
  private final Map<String, String> commands = new ConcurrentHashMap<>();

  public Storage() {
    commands.put("uptime", "Show server uptime");
    commands.put("info", "Show server information");
    commands.put("help", "Show list of available commands");
    commands.put("stop", "Stop server");
    information.put("version", "0.1.0");
    information.put("creation date", "06.06.2024");
  }

  public Map<String, String> getCommands() {
    return commands;
  }

  public Map<String, String> getInformation() {
    return information;
  }
}

====================
FILE: src/main/java/user/Role.java

package user;

public enum Role {
  USER, ADMIN
}

====================
FILE: src/main/java/user/RoleMapper.java

package user;

import db.enums.UsersRole;

public class RoleMapper {

  public static Role toRole(UsersRole usersRole) {
    if (usersRole == null) {
      return null;
    }
    switch (usersRole) {
      case USER:
        return Role.USER;
      case ADMIN:
        return Role.ADMIN;
      default:
        throw new IllegalArgumentException("Unknown role: " + usersRole);
    }
  }

  // Convert from Role (your enum) to UsersRole (jOOQ)
  public static UsersRole toUsersRole(Role role) {
    if (role == null) {
      return null;
    }
    switch (role) {
      case USER:
        return UsersRole.USER;
      case ADMIN:
        return UsersRole.ADMIN;
      default:
        throw new IllegalArgumentException("Unknown role: " + role);
    }
  }
}


====================
FILE: src/main/java/user/User.java

package user;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.ArrayList;
import java.util.List;
import message.Message;

public class User {

  private String username;
  private String password;
  private Role role;
  private List<Message> messages;

  public User(
      @JsonProperty("username") String username,
      @JsonProperty("password") String password,
      @JsonProperty("role") Role role) {
    this.username = username;
    this.password = password;
    this.role = role != null ? role : Role.USER;
    this.messages = new ArrayList<>();
  }

  public User(String username, Role role) {
    this.username = username;
    this.role = role;
  }

  public User(String username, Role role, String password) {
    this.username = username;
    this.role = role;
    this.password = password;
  }


  public String getUsername() {
    return username;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public Role getRole() {
    return role;
  }

  public List<Message> getMessages() {
    return messages;
  }

  @Override
  public String toString() {
    return "User{" +
        "username='" + username + '\'' +
        ", password='" + password + '\'' +
        ", role=" + role +
        '}';
  }
}
====================
FILE: src/main/java/user/UserService.java

package user;

import static db.tables.Users.USERS;
import static org.jooq.impl.DSL.selectFrom;
import static user.RoleMapper.toRole;
import static user.RoleMapper.toUsersRole;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import database.Database;
import java.util.Map;
import java.util.stream.Collectors;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import org.mindrot.jbcrypt.BCrypt;

public class UserService {

  private final ObjectMapper objectMapper = new ObjectMapper();
  private static final Logger logger = LogManager.getLogger(UserService.class);
  private final Database database = new Database();
  private final DSLContext create = database.getDSLContext();
  private final int MIN_PASSWORD_LENGTH = 4;

  public User getUser(String username) {
    return create.selectFrom(USERS)
        .where(USERS.USERNAME.eq(username))
        .fetchOne(record -> new User(
            record.getValue(USERS.USERNAME),
            toRole(record.getValue(USERS.ROLE))
        ));
  }

  public String getUsers() {
    Map<String, User> users = create.selectFrom(USERS)
        .fetchStream()
        .collect(Collectors.toMap(
            record -> record.getValue(USERS.USERNAME),
            record -> new User(
                record.getValue(USERS.USERNAME),
                toRole(record.getValue(USERS.ROLE))
            )
        ));
    if (users.isEmpty()) {
      return "{\"message\": \"No users in the list\"}";
    }
    try {
      return objectMapper.writeValueAsString(users);
    } catch (JsonProcessingException e) {
      return "{\"error\": \"Unable to process users list\"}";
    }
  }

  public String addUser(String userJson) {
    try {
      User user = objectMapper.readValue(userJson, User.class);

      if (user.getPassword().length() < MIN_PASSWORD_LENGTH) {
        return "{\"error\": \"Password length must be at least 4 characters\"}";
      }

      String hashedPassword = BCrypt.hashpw(user.getPassword(), BCrypt.gensalt());

      return create.transactionResult(configuration -> {
        DSLContext ctx = DSL.using(configuration);

        if (ctx.fetchExists(
            ctx.selectFrom(USERS).where(USERS.USERNAME.eq(user.getUsername()))
        )) {
          return "{\"error\": \"User already exists\"}";
        }

        // Insert the new user
        ctx.insertInto(USERS)
            .set(USERS.USERNAME, user.getUsername())
            .set(USERS.PASSWORD, hashedPassword)
            .set(USERS.ROLE, toUsersRole(user.getRole())) // Convert Role to jOOQ UsersRole
            .execute();

        return "{\"message\": \"User added successfully\"}";
      });

    } catch (JsonProcessingException e) {
      return "{\"error\": \"Unable to add user\"}";
    }
  }

  public String removeUser(String username) {
    int deletedRows = create.deleteFrom(USERS)
        .where(USERS.USERNAME.eq(username))
        .execute();

    if (deletedRows > 0) {
      return "{\"message\": \"User removed successfully\"}";
    } else {
      return "{\"error\": \"User not found\"}";
    }
  }

  public String loginUser(String userJson) {
    System.out.println("XXXXXXXXXXx");
    try {
      User user = objectMapper.readValue(userJson, User.class);
      logger.info("Login user: " + user);

      User foundUser = create.selectFrom(USERS)
          .where(USERS.USERNAME.eq(user.getUsername()))
          .fetchOne(record -> new User(
              record.getValue(USERS.USERNAME),
              toRole(record.getValue(USERS.ROLE)),
              record.getValue(USERS.PASSWORD)
          ));

      if (foundUser == null) {
        return "{\"error\": \"User not found\"}";
      }

      if (BCrypt.checkpw(user.getPassword(), foundUser.getPassword())) {
        return String.format(
            "{\"message\": \"User logged in successfully\", \"role\": \"%s\"}",
            foundUser.getRole()
        );
      } else {
        return "{\"error\": \"Invalid credentials\"}";
      }
    } catch (JsonProcessingException e) {
      return "{\"error\": \"Unable to process login request\"}";
    }
  }
}
====================
FILE: src/main/java/user/UserSession.java

package user;

public class UserSession {
  private boolean loggedIn;
  private String username;
  private Role role;

  public UserSession() {
    this.loggedIn = false;
    this.username = null;
    this.role = Role.USER;
  }

  public boolean isLoggedIn() {
    return loggedIn;
  }

  public void login(String username, Role role) {
    this.loggedIn = true;
    this.username = username;
    this.role = role;
  }

  public void logout() {
    this.loggedIn = false;
    this.username = null;
    this.role = Role.USER;
  }

  public String getUsername() {
    return username;
  }

  public Role getRole() {
    return role;
  }
}

====================
FILE: src/test/java/message/MessageServiceTest.java

package message;

import static db.Tables.MESSAGES;
import static db.Tables.USERS;
import static org.junit.jupiter.api.Assertions.assertEquals;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import database.Database;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import org.jooq.DSLContext;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.UserService;

class MessageServiceTest {

  private UserService userService;
  private MessageService messageService;
  private Database database;
  private ObjectMapper objectMapper;


  @BeforeEach
  void setUp() {
    userService = new UserService();
    database = new Database();
    messageService = new MessageService();
    objectMapper = new ObjectMapper();
    clearDatabase();
  }

  private void clearDatabase() {
    DSLContext create = database.getDSLContext();

    create.deleteFrom(MESSAGES).execute(); // Delete all messages
    create.deleteFrom(USERS).execute();
  }

  private String addUser(String username, String password, String role) {
    String userJson = String.format("{\"username\":\"%s\",\"password\":\"%s\",\"role\":\"%s\"}", username, password, role);
    return userService.addUser(userJson);
  }

  @Test
  @DisplayName("Should correctly send message from user to admin")
  void shouldSendMessageFromUserToAdmin() {
    // given
    addUser("john", "pass", "USER");
    addUser("admin", "admin", "ADMIN");

    String messageJson = "{\"sender\":\"john\",\"receiver\":\"admin\",\"content\":\"Hello admin\"}";

    // when
    String result = messageService.sendMessage(messageJson);

    // then
    assertEquals("{\"message\": \"Message sent\"}", result);
  }

  @Test
  @DisplayName("Should correctly send message from user to admin and read it")
  void shouldSendMessageFromUserToAdminAndReadIt() throws Exception {
    // given
    addUser("john", "pass", "USER");
    addUser("admin", "admin", "ADMIN");

    String messageJson = "{\"sender\":\"john\",\"receiver\":\"admin\",\"content\":\"Hello admin\"}";
    messageService.sendMessage(messageJson);

    // when
    String result = messageService.readMessages("{\"username\":\"admin\"}");

    JsonNode resultNode = objectMapper.readTree(result);
    String createdDate = resultNode.get(0).get("createdDate").asText();

    // then
    String expectedMessage = String.format(
        "[{\"content\":\"Hello admin\",\"sender\":\"john\",\"receiver\":\"admin\",\"createdDate\":\"%s\"}]",
        createdDate
    );

    assertEquals(expectedMessage, result);
  }


  @Test
  @DisplayName("Should not send message from user to unknown user")
  void shouldNotSendMessageFromUserToUnknownUser() {
    // given
    addUser("john", "pass", "USER");
    String messageJson = "{\"sender\":\"john\",\"receiver\":\"gall\",\"content\":\"Hello gall\"}";

    // when
    String result = messageService.sendMessage(messageJson);

    // then
    assertEquals("{\"error\": \"Receiver not found\"}", result);
  }

  @Test
  @DisplayName("Should not send message if text too long")
  void shouldNotSendMessageIfTextTooLong() {
    // given
    addUser("john", "pass", "USER");
    addUser("admin", "admin", "ADMIN");
    String messageJson = "{\"sender\":\"john\",\"receiver\":\"admin\",\"content\":\"Hello admin, I hope you are doing well. I am writing to you to ask for a favor. I need you to help me with a project that I am working on. I need you to provide me with some information that I am missing. I hope you can help me with this. Thank you very much for your help. I really appreciate it.\"}";

    // when
    String result = messageService.sendMessage(messageJson);

    // then
    assertEquals("{\"error\": \"Message is too long\"}", result);
  }

  @Test
  @DisplayName("Should not send message if mailbox is full")
  void shouldNotSendMessageIfMailboxIsFull() {
    // given
    addUser("john", "pass", "USER");
    addUser("admin", "admin", "ADMIN");
    String messageJson = "{\"sender\":\"john\",\"receiver\":\"admin\",\"content\":\"Hello admin\"}";
    int MAILBOX_CAPACITY = 5;
    for (int i = 0; i < MAILBOX_CAPACITY; i++) {
      messageService.sendMessage(messageJson);
    }

    // when
    String result = messageService.sendMessage(messageJson);

    // then
    assertEquals("{\"error\": \"Receiver mailbox is full, cannot send message\"}", result);
  }

  @Test
  @DisplayName("Should not send message if sender not found")
  void shouldNotSendMessageIfSenderNotFound() {
    // given
    addUser("john", "pass", "USER");
    String messageJson = "{\"sender\":\"gall\",\"receiver\":\"mike\",\"content\":\"Hello john\"}";

    // when
    String result = messageService.sendMessage(messageJson);

    // then
    assertEquals("{\"error\": \"Receiver not found\"}", result);
  }

  @Test
  @DisplayName("Should return message about empty mailbox if mailbox is empty")
  void shouldReturnMessageAboutEmptyMailboxIfMailboxIsEmpty() {
    // given
    addUser("john", "pass", "USER");

    // when
    String result = messageService.readMessages("{\"username\":\"john\"}");

    // then
    assertEquals("{\"message\": \"Mailbox is empty\"}", result);
  }
}

====================
FILE: src/test/java/user/UserServiceTest.java

package user;

import static db.Tables.MESSAGES;
import static db.Tables.USERS;
import static org.junit.jupiter.api.Assertions.assertEquals;

import database.Database;
import java.io.IOException;
import org.jooq.DSLContext;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class UserServiceTest {

  private UserService userService;
  private Database database;

  @BeforeEach
  void setUp() {
    userService = new UserService();
    database = new Database();
    clearDatabase();
  }

  private void clearDatabase() {
    DSLContext create = database.getDSLContext();

    create.deleteFrom(MESSAGES).execute();
    create.deleteFrom(USERS).execute();
  }

  private String addUser(String username, String password, String role) {
    String userJson = String.format("{\"username\":\"%s\",\"password\":\"%s\",\"role\":\"%s\"}", username, password, role);
    return userService.addUser(userJson);
  }

  @Test
  @DisplayName("Should correctly add user with role user to database and return success message")
  void shouldAddUserWithRoleUserToDatabase() {
    // given
    // when
    String result = addUser("john", "pass", "USER");

    // then
    assertEquals("{\"message\": \"User added successfully\"}", result);
  }

  @Test
  @DisplayName("Should correctly add user with role user to database and return success message")
  void shouldAddUserWithRoleAdminToDatabase() {
    // given
    // when
    String result = addUser("john", "pass", "ADMIN");

    // then
    assertEquals("{\"message\": \"User added successfully\"}", result);
  }

  @Test
  @DisplayName("Should not correctly add user with unknown role to database and return error message")
  void shouldNotAddUserWithUnknownRoleToDatabase() {
    // given
    // when
    String result = addUser("john", "pass", "DRIVER");

    // then
    assertEquals("{\"error\": \"Unable to add user\"}", result);
  }

  @Test
  @DisplayName("Should not correctly add user if password is too short and return error message")
  void shouldNotAddUserToDatabaseIfPasswordTooShort() {
    // given
    // when
    String result = addUser("john", "p", "ADMIN");

    // then
    assertEquals("{\"error\": \"Password length must be at least 4 characters\"}", result);
  }

  @Test
  @DisplayName("Should not correctly add user with unknown format to database and return error message")
  void shouldNotAddUserWithUnknownFormatToDatabase() {
    // given
    String userJson = "{\"name\":\"john\",\"pw\":\"pass\",\"role\":\"ADMIN\"}";

    // when
    String result = userService.addUser(userJson);

    // then
    assertEquals("{\"error\": \"Unable to add user\"}", result);
  }

  @Test
  @DisplayName("Should correctly log in user with correct credentials and return success message")
  void shouldSuccessfullyLoginToAppWithCorrectCredentials() {
    // given
    addUser("john", "pass", "ADMIN");

    // when
    String loginResult = userService.loginUser("{\"username\":\"john\",\"password\":\"pass\"}");

    // then
    assertEquals("{\"message\": \"User logged in successfully\", \"role\": \"ADMIN\"}", loginResult);
  }

  @Test
  @DisplayName("Should not log in user with incorrect credentials and return error message")
  void shouldUnsuccessfullyLoginToAppWithIncorrectCredentials() {
    // given
    addUser("john", "pass", "USER");

    // when
    String result = userService.loginUser("{\"username\":\"john\",\"password\":\"wrong\"}");

    // then
    assertEquals("{\"error\": \"Invalid credentials\"}", result);
  }

  @Test
  @DisplayName("Should not add two users with the same names and return error message")
  void shouldNotAddTwoUsersWithSameNames() {
    // given
    // when
    addUser("john", "pass", "USER");
    String resultOfRepeatedUser = addUser("john", "pass", "USER");

    // then
    assertEquals("{\"error\": \"User already exists\"}", resultOfRepeatedUser);
  }

  @Test
  @DisplayName("Should return empty list")
  void shouldCorrectlyReturnEmptyList() {
    // given
    // when
    String result = userService.getUsers();

    // then
    assertEquals("{\"message\": \"No users in the list\"}", result);
  }

  @Test
  @DisplayName("Should return list with five users")
  void shouldCorrectlyReturnListWithFiveUsers() {
    // given
    String userJsonOne = "{\"username\":\"john\",\"password\":\"pass\",\"role\":\"ADMIN\"}";
    String userJsonTwo = "{\"username\":\"colin\",\"password\":\"pass\",\"role\":\"ADMIN\"}";
    String userJsonThree = "{\"username\":\"Calum\",\"password\":\"pass\",\"role\":\"ADMIN\"}";
    String userJsonFour = "{\"username\":\"Declan\",\"password\":\"pass\",\"role\":\"ADMIN\"}";
    String userJsonFive = "{\"username\":\"Mike\",\"password\":\"pass\",\"role\":\"ADMIN\"}";

    // when
    userService.addUser(userJsonOne);
    userService.addUser(userJsonTwo);
    userService.addUser(userJsonThree);
    userService.addUser(userJsonFour);
    userService.addUser(userJsonFive);
    String result = userService.getUsers();

    // then
    assertEquals(
        "{\"Declan\":{\"username\":\"Declan\",\"password\":null,\"role\":\"ADMIN\",\"messages\":null},\"colin\":{\"username\":\"colin\",\"password\":null,\"role\":\"ADMIN\",\"messages\":null},\"Mike\":{\"username\":\"Mike\",\"password\":null,\"role\":\"ADMIN\",\"messages\":null},\"john\":{\"username\":\"john\",\"password\":null,\"role\":\"ADMIN\",\"messages\":null},\"Calum\":{\"username\":\"Calum\",\"password\":null,\"role\":\"ADMIN\",\"messages\":null}}",
        result);
  }

  @Test
  @DisplayName("Should correctly return list with one user after delete")
  void shouldCorrectlyRemoveUser() {
    // given
    String userJsonOne = "{\"username\":\"john\",\"password\":\"pass\",\"role\":\"ADMIN\"}";
    String userJsonTwo = "{\"username\":\"colin\",\"password\":\"pass\",\"role\":\"ADMIN\"}";

    // when
    userService.addUser(userJsonOne);
    userService.addUser(userJsonTwo);
    String resultBeforeRemove = userService.getUsers();
    String confirmRemove = userService.removeUser("john");
    String resultAfterRemove = userService.getUsers();

    // then
    assertEquals(
        "{\"colin\":{\"username\":\"colin\",\"password\":null,\"role\":\"ADMIN\",\"messages\":null},\"john\":{\"username\":\"john\",\"password\":null,\"role\":\"ADMIN\",\"messages\":null}}",
        resultBeforeRemove);
    assertEquals(
        "{\"colin\":{\"username\":\"colin\",\"password\":null,\"role\":\"ADMIN\",\"messages\":null}}",
        resultAfterRemove);
    assertEquals("{\"message\": \"User removed successfully\"}", confirmRemove);
  }


}



